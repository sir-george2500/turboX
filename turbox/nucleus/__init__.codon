# Nucleus - TurboX High-Performance HTTP Server Core
# 
# This module provides the core HTTP server functionality for TurboX,
# compiled to native code via Codon for maximum performance.
#
# All components are defined in this single file for easier import resolution.

from C import (
    socket(i32, i32, i32) -> i32,
    setsockopt(i32, i32, i32, Ptr[byte], u32) -> i32,
    bind(i32, Ptr[byte], u32) -> i32,
    listen(i32, i32) -> i32,
    accept(i32, Ptr[byte], Ptr[u32]) -> i32,
    recv(i32, Ptr[byte], int, i32) -> int,
    send(i32, Ptr[byte], int, i32) -> int,
    close(i32) -> i32,
    htons(u16) -> u16,
    inet_addr(Ptr[byte]) -> u32,
    perror(Ptr[byte])
)

# Socket constants
AF_INET = i32(2)
SOCK_STREAM = i32(1)
SOL_SOCKET = i32(1)
SO_REUSEADDR = i32(2)

@tuple
class sockaddr_in:
    """C sockaddr_in structure for socket addressing"""
    sin_family: i16      # Address family (AF_INET)
    sin_port: u16        # Port in network byte order
    sin_addr: u32        # IP address
    sin_zero: u64        # Padding to match C struct size


# ========== Request Module ==========

class Request:
    """HTTP Request object with parsed components"""
    method: str
    path: str
    query_params: Dict[str, str]
    headers: Dict[str, str]
    body: str
    
    def __init__(self, method: str, path: str, query_params: Dict[str, str], 
                 headers: Dict[str, str], body: str):
        self.method = method
        self.path = path
        self.query_params = query_params
        self.headers = headers
        self.body = body


def parse_query_string(query: str) -> Dict[str, str]:
    """Parse URL query string into dictionary"""
    params = Dict[str, str]()
    if not query:
        return params
    
    pairs = query.split('&')
    for pair in pairs:
        if '=' in pair:
            parts = pair.split('=', 1)
            params[parts[0]] = parts[1]
    return params


def parse_request(request_data: str) -> Request:
    """Parse raw HTTP request into Request object"""
    lines = request_data.split('\\r\\n')
    
    # Parse request line (e.g., "GET /path HTTP/1.1")
    request_line = lines[0].split(' ')
    method = request_line[0]
    full_path = request_line[1]
    
    # Parse path and query parameters
    path = full_path
    query_params = Dict[str, str]()
    
    if '?' in full_path:
        parts = full_path.split('?', 1)
        path = parts[0]
        query_params = parse_query_string(parts[1])
    
    # Parse headers
    headers = Dict[str, str]()
    body_start = 0
    
    for i in range(1, len(lines)):
        line = lines[i]
        if line == '':
            body_start = i + 1
            break
        if ': ' in line:
            parts = line.split(': ', 1)
            headers[parts[0].lower()] = parts[1]
    
    # Extract body
    body = ''
    if body_start < len(lines):
        body_lines = lines[body_start:]
        body = '\\r\\n'.join(body_lines)
    
    return Request(method, path, query_params, headers, body)


# ========== Response Module ==========

def build_response(body: str, status: int = 200) -> str:
    """Build HTTP response with proper headers"""
    status_msg = 'OK'
    if status == 404:
        status_msg = 'Not Found'
    elif status == 500:
        status_msg = 'Internal Server Error'
    elif status == 400:
        status_msg = 'Bad Request'
    
    response = f'HTTP/1.1 {status} {status_msg}\\r\\n'
    response += 'Content-Type: text/plain\\r\\n'
    response += f'Content-Length: {len(body)}\\r\\n'
    response += 'Connection: close\\r\\n'
    response += '\\r\\n'
    response += body
    
    return response


# ========== Server Module ==========

class TurboX:
    """TurboX HTTP Server
    
    High-performance HTTP server using C FFI for socket operations.
    Compiled to native code for maximum performance.
    """
    host: str
    port: int
    routes: Dict[str, Callable[[Request], str]]
    
    def __init__(self, host: str = '127.0.0.1', port: int = 8000):
        """Initialize TurboX server"""
        self.host = host
        self.port = port
        self.routes = Dict[str, Callable[[Request], str]]()
    
    def handle_request(self, request_data: str) -> str:
        """Handle incoming HTTP request"""
        try:
            req = parse_request(request_data)
            route_key = f'{req.method}:{req.path}'
            
            if route_key in self.routes:
                handler = self.routes[route_key]
                result = handler(req)
                return build_response(result, 200)
            else:
                return build_response('Not Found', 404)
        except:
            return build_response('Internal Server Error', 500)
    
    def run(self):
        """Start the HTTP server"""
        # Create socket
        sockfd = socket(AF_INET, SOCK_STREAM, i32(0))
        if sockfd < i32(0):
            perror('socket'.c_str())
            return
        
        # Enable SO_REUSEADDR to allow quick restart
        optval = i32(1)
        setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, Ptr[byte](__ptr__(optval)), u32(4))
        
        # Bind to address
        addr = sockaddr_in(
            i16(AF_INET),
            htons(u16(self.port)),
            inet_addr(self.host.c_str()),
            u64(0)
        )
        
        if bind(sockfd, Ptr[byte](__ptr__(addr)), u32(16)) < i32(0):
            perror('bind'.c_str())
            close(sockfd)
            return
        
        # Listen for connections
        if listen(sockfd, i32(5)) < i32(0):
            perror('listen'.c_str())
            close(sockfd)
            return
        
        print(f'TurboX server running on http://{self.host}:{self.port}')
        print('Press Ctrl+C to stop')
        
        buffer = Ptr[byte](4096)
        addr_len = u32(16)
        
        # Main request loop
        while True:
            client_fd = accept(sockfd, cobj(), Ptr[u32](__ptr__(addr_len)))
            
            if client_fd < i32(0):
                continue
            
            # Receive request
            bytes_received = recv(client_fd, buffer, 4096, i32(0))
            
            if bytes_received > 0:
                request_str = str(buffer, bytes_received)
                response = self.handle_request(request_str)
                send(client_fd, response.ptr, len(response), i32(0))
            
            close(client_fd)
        
        close(sockfd)
